# PROMPT PREAMBLE FOR CLAUDE CODE / AGENTIC CODING

For this project, write a detailed FORKUUSHO.md file that explains the whole project in plain language.

Explain the technical architecture, the structure of the codebase and how the various parts are connected, the technologies used, why we made these technical decisions, and lessons I can learn from it (this should include the bugs we ran into and how we fixed them, potential pitfalls and how to avoid them in the future, new technologies used, how good engineers think and work, best practices, etc).

It should be very engaging to read; don't make it sound like boring technical documentation/textbook. Where appropriate, use analogies and anecdotes to make it more understandable and memorable.

**ALWAYS use this as a framework to follow for prompts directed at claude code:**

1. **Plan & Research**: Before writing any code, analyze the problem space thoroughly. Requirements: (1) Clarify the goal - what exactly needs to be built and why; (2) Identify constraints, dependencies, and edge cases; (3) Research existing patterns, APIs, or libraries that apply; (4) Outline the architecture and data flow; (5) List unknowns and risks. Do not simplify anything or stub it. Deliverable: A written plan I can review before implementation begins. Ask clarifying questions if requirements are ambiguous.

2. **Implement Plan**: Execute the agreed plan step-by-step. Requirements: (1) Follow the plan sequentially, noting any deviations; (2) Write real, functional code - no stubs, placeholders, or TODOs; (3) Handle errors and edge cases as you go; (4) Commit logical chunks with clear explanations. If you encounter blockers or the plan needs revision, stop and discuss before proceeding. Be careful to always implement fully finished, fully fleshed out working production code. Do not use try catch or fallbacks or other defensive programming patterns unless necessary. Do not stub code or TODO or simplify -- always do the most complete version, even if its very complex.

3. **Keep Going**: Continue working through all remaining tasks until complete. For each item: implement it fully, verify it works, then move to the next. Don't stop to ask permission between items. Be careful to always implement fully finished, fully fleshed out working production code. Do not use try catch or fallbacks or other defensive programming patterns unless necessary. Do not stub code or TODO or simplify -- always do the most complete version, even if its very complex. Provide a final summary of what was completed and anything that remains blocked.

4. **Code Quality Pass**: Review and refactor the current code for quality. Criteria: (1) Compact - remove dead code, redundancy, over-abstraction; (2) Concise - simplify verbose logic, use idiomatic patterns; (3) Clean - consistent naming, clear structure, proper formatting; (4) Capable - handles edge cases, fails gracefully, performs well. Make sure work is fully finished. Show the refactored code with brief explanations of changes.

5. **Thorough Testing**: Review test coverage -- make sure it is expanded beyond the happy path and covers all buttons, routes, flows, code etc. Requirements: (1) Test boundary conditions and edge cases; (2) Test error handling and invalid inputs; (3) Test integration points with real dependencies where possible; (4) Test concurrent/async behavior if applicable; (5) Verify actual outputs match expected - inspect the data. Tests must exercise real code paths, not mocks of the code under test.

6. **LARP Assessment**: Critically evaluate whether this code is real or performative. Check for: (1) Stubbed functions that return fake data; (2) Hardcoded values masquerading as dynamic behavior; (3) Tests that mock away the actual logic being tested; (4) Error handling that silently swallows failures; (5) Async code that doesn't actually await; (6) Validation that doesn't validate; (7) Any code path that hasn't been executed and verified. Report findings honestly. If something looks functional but isn't proven, flag it. Once you've done your review, immediately fix every issue, step by step, from most complicated to simplest. Make sure to have TODOs to keep track

7. **Clean Up Slop**: Remove AI-generated cruft and over-engineering. Target: (1) Unnecessary abstractions and wrapper functions; (2) Verbose comments that restate the obvious; (3) Defensive code for impossible conditions; (4) Over-generic solutions for specific problems; (5) Redundant null checks and type assertions; (6) Enterprise patterns in simple scripts; (7) Filler words and hedging in strings/docs. Keep what adds value, delete what adds noise.

8. **Production Readiness Validation**: Final checklist before deployment. Verify: (1) All tests pass with real execution, not mocked; (2) Error handling covers failure modes with proper logging; (3) Configuration is externalized, no hardcoded secrets; (4) Performance is acceptable under expected load; (5) Dependencies are pinned and security-scanned; (6) Rollback path exists; (7) Monitoring/alerting is in place. Demonstrate each item is satisfied with evidence, not assertions. If you find anything that needs to be fixed, make a TODO for it and then do all fix TODOs.

9. **Review Last Task**: Audit what was just completed. Questions: (1) Does it actually work - did you verify the output? (2) Does it solve the original problem or just part of it? (3) Did anything get skipped or deferred? (4) Are there assumptions that should be documented? (5) What could break this in production? Give me an honest assessment, not a confident summary. After your assessment, make TODOs for each thing that is not completed, and fix.

10. **Fix All Remaining Issues**: Systematically resolve everything outstanding. Process: (1) List every open issue - bugs, TODOs, skipped tests, known limitations; (2) Prioritize by impact; (3) Fix each one completely before moving to the next; (4) Verify each fix with actual execution; (5) Re-run full test suite after each fix to catch regressions. Do not mark complete until zero issues remain. Be careful to always implement fully finished, fully fleshed out working production code. Do not use try catch or fallbacks or other defensive programming patterns unless necessary. Do not stub code or TODO or simplify -- always do the most complete version, even if its very complex.

**ALWAYS FOLLOW THIS PROMPT**

"Maintain an `implementation_log.md` file. This log should track: (1) Key technical decisions and rationales (in a table format); (2) Listings of files created, modified, or deleted; (3) Summaries of completed phases or features; (4) Specific implementation details like design system choices (colors, fonts, animations) or architectural patterns; (5) Any issues encountered and how they were resolved; (6) Any deviations from the original plan and why they were made. (7) Any TODOs that were created and why they were created. Most Importantly (8) how every script is used, the results/output of the script, and any issues encountered while using the script, in addition, show a summary of the prompt, what it demanded and how the specific scripts help you get the desired results/output. Update this log after every significant step or phase completion to ensure a comprehensive history of the project is preserved."
